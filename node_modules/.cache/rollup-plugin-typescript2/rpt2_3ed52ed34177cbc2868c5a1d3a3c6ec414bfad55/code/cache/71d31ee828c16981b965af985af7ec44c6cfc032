{"code":"import { findValueByPath } from './utils';\r\nexport function parseExpression(exp, values, defaultValues = {}) {\r\n    var _a, _b, _c;\r\n    if (values) {\r\n        exp = exp.trim();\r\n        let { value, found } = findValueByPath(values, exp);\r\n        if (!found || value === null) {\r\n            let defaults = findValueByPath(defaultValues, exp);\r\n            if (defaults.found) {\r\n                return defaults.value;\r\n            }\r\n        }\r\n        if (found) {\r\n            return value;\r\n        }\r\n        // Dynamic variables\r\n        if (exp === '$NOW') {\r\n            return new Date();\r\n        }\r\n        if (exp.startsWith('$CURRENT_USER')) {\r\n            if (exp === '$CURRENT_USER') {\r\n                return (_a = values.__currentUser) === null || _a === void 0 ? void 0 : _a.id;\r\n            }\r\n            return findValueByPath({ $CURRENT_USER: values.__currentUser }, exp).value;\r\n        }\r\n        const opMatch = parseOp(exp);\r\n        if (opMatch) {\r\n            const { op, args } = opMatch;\r\n            // unary operators\r\n            if (args.length === 1) {\r\n                const valueA = parseExpression(args[0], values, defaultValues);\r\n                // type conversion\r\n                if (op === 'INT') {\r\n                    return parseInt(valueA);\r\n                }\r\n                if (op === 'FLOAT') {\r\n                    return parseFloat(valueA);\r\n                }\r\n                if (op === 'STRING') {\r\n                    return String(valueA);\r\n                }\r\n                if (op === 'DATE') {\r\n                    return new Date(valueA);\r\n                }\r\n                // format\r\n                if (op === 'SLUG') {\r\n                    return toSlug(valueA);\r\n                }\r\n                if (op === 'CURRENCY') {\r\n                    return new Intl.NumberFormat().format(valueA);\r\n                }\r\n                // date\r\n                if (op === 'DATE_ISO') {\r\n                    return new Date(valueA).toISOString();\r\n                }\r\n                if (op === 'DATE_UTC') {\r\n                    return new Date(valueA).toUTCString();\r\n                }\r\n                if (['YEAR', 'MONTH', 'GET_DATE', 'DAY', 'HOURS', 'MINUTES', 'SECONDS', 'TIME'].includes(op)) {\r\n                    if (valueA instanceof Date) {\r\n                        const op2func = {\r\n                            YEAR: 'getFullYear',\r\n                            MONTH: 'getMonth',\r\n                            GET_DATE: 'getDate',\r\n                            DAY: 'getDay',\r\n                            HOURS: 'getHours',\r\n                            MINUTES: 'getMinutes',\r\n                            SECONDS: 'getSeconds',\r\n                            TIME: 'getTime',\r\n                        };\r\n                        return valueA[op2func[op]]();\r\n                    }\r\n                    return 0;\r\n                }\r\n                // arithmetic\r\n                if (op === 'ABS') {\r\n                    return Math.abs(valueA);\r\n                }\r\n                if (op === 'SQRT') {\r\n                    return Math.sqrt(valueA);\r\n                }\r\n                if (op === 'SUM') {\r\n                    if (valueA instanceof Array) {\r\n                        return valueA.reduce((partialSum, a) => partialSum + a, 0);\r\n                    }\r\n                    return 0;\r\n                }\r\n                if (op === 'AVERAGE') {\r\n                    if (valueA instanceof Array) {\r\n                        return valueA.reduce((partialSum, a) => partialSum + a, 0) / valueA.length;\r\n                    }\r\n                    return 0;\r\n                }\r\n                // boolean\r\n                if (op === 'NULL') {\r\n                    return valueA === null;\r\n                }\r\n                if (op === 'NOT_NULL') {\r\n                    return valueA !== null;\r\n                }\r\n                if (op === 'NOT') {\r\n                    return !valueA;\r\n                }\r\n                // string\r\n                if (op === 'STR_LEN') {\r\n                    return String(valueA).length;\r\n                }\r\n                if (op === 'LOWER') {\r\n                    return String(valueA).toLowerCase();\r\n                }\r\n                if (op === 'UPPER') {\r\n                    return String(valueA).toUpperCase();\r\n                }\r\n                if (op === 'TRIM') {\r\n                    return String(valueA).trim();\r\n                }\r\n                // array\r\n                if (op === 'ARRAY_LEN') {\r\n                    if (valueA instanceof Array) {\r\n                        return valueA.length;\r\n                    }\r\n                    return 0;\r\n                }\r\n            }\r\n            else if (op === 'ASUM' && args.length === 2) {\r\n                // aggregated sum\r\n                return ((_c = (_b = values[args[0]]) === null || _b === void 0 ? void 0 : _b.reduce((acc, item) => acc + parseExpression(args[1], item, {}), 0)) !== null && _c !== void 0 ? _c : 0);\r\n            }\r\n            else if (args.length === 2) {\r\n                // binary operators\r\n                const valueA = parseExpression(args[0], values, defaultValues);\r\n                const valueB = parseExpression(args[1], values, defaultValues);\r\n                // arithmetic\r\n                if (op === 'SUM') {\r\n                    return valueA + valueB;\r\n                }\r\n                if (op === 'SUBTRACT') {\r\n                    return valueA - valueB;\r\n                }\r\n                if (op === 'MULTIPLY') {\r\n                    return valueA * valueB;\r\n                }\r\n                if (op === 'DIVIDE') {\r\n                    return valueA / valueB;\r\n                }\r\n                if (op === 'REMAINDER') {\r\n                    return valueA % valueB;\r\n                }\r\n                if (op === 'ROUND') {\r\n                    return valueA.toFixed(valueB);\r\n                }\r\n                if (op === 'MAX') {\r\n                    return Math.max(valueA, valueB);\r\n                }\r\n                if (op === 'MIN') {\r\n                    return Math.min(valueA, valueB);\r\n                }\r\n                if (op === 'POWER') {\r\n                    return Math.pow(valueA, valueB);\r\n                }\r\n                // string\r\n                if (op === 'CONCAT') {\r\n                    return String(valueA) + String(valueB);\r\n                }\r\n                if (op === 'LEFT') {\r\n                    return String(valueA).slice(0, Number(valueB));\r\n                }\r\n                if (op === 'RIGHT') {\r\n                    return String(valueA).slice(-Number(valueB));\r\n                }\r\n                // boolean\r\n                if (op === 'EQUAL') {\r\n                    return valueA === valueB;\r\n                }\r\n                if (op === 'NOT_EQUAL') {\r\n                    return valueA !== valueB;\r\n                }\r\n                if (op === 'GT') {\r\n                    return valueA > valueB;\r\n                }\r\n                if (op === 'GTE') {\r\n                    return valueA >= valueB;\r\n                }\r\n                if (op === 'LT') {\r\n                    return valueA < valueB;\r\n                }\r\n                if (op === 'LTE') {\r\n                    return valueA <= valueB;\r\n                }\r\n                if (op === 'AND') {\r\n                    return valueA && valueB;\r\n                }\r\n                if (op === 'OR') {\r\n                    return valueA || valueB;\r\n                }\r\n            }\r\n            else if (args.length === 3) {\r\n                if (op === 'IF') {\r\n                    if (parseExpression(args[0], values, defaultValues) === true) {\r\n                        return parseExpression(args[1], values, defaultValues);\r\n                    }\r\n                    return parseExpression(args[2], values, defaultValues);\r\n                }\r\n            }\r\n        }\r\n        // number literal\r\n        if (!isNaN(parseFloat(exp))) {\r\n            return parseFloat(exp);\r\n        }\r\n        throw new Error(`Cannot parse expression: ${exp}`);\r\n    }\r\n    return '';\r\n}\r\nexport function parseOp(exp) {\r\n    const match = exp.match(/^([A-Z_]+)\\((.+)\\)$/);\r\n    if (match) {\r\n        const args = [];\r\n        const op = match[1];\r\n        const innerExp = match[2];\r\n        let braceCount = 0, i = 0, j = 0;\r\n        for (; i < innerExp.length; i += 1) {\r\n            const c = innerExp[i];\r\n            if (c === '(')\r\n                braceCount += 1;\r\n            if (c === ')')\r\n                braceCount -= 1;\r\n            if (c === ',' && braceCount === 0) {\r\n                args.push(innerExp.slice(j, i));\r\n                j = i + 1;\r\n            }\r\n        }\r\n        if (j < i) {\r\n            args.push(innerExp.slice(j, i));\r\n        }\r\n        return { op, args };\r\n    }\r\n    return null;\r\n}\r\nexport function toSlug(str) {\r\n    if (typeof str !== 'string') {\r\n        return '';\r\n    }\r\n    let res = str.replace(/^\\s+|\\s+$/g, ''); // trim\r\n    res = res.toLowerCase();\r\n    // remove accents\r\n    const from = 'àáãảạăằắẳẵặâầấẩẫậèéẻẽẹêềếểễệđùúủũụưừứửữựòóỏõọôồốổỗộơờớởỡợìíỉĩịäëïîöüûñçýỳỹỵỷ';\r\n    const to = 'aaaaaaaaaaaaaaaaaeeeeeeeeeeeduuuuuuuuuuuoooooooooooooooooiiiiiaeiiouuncyyyyy';\r\n    for (let i = 0, l = from.length; i < l; i++) {\r\n        res = res.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));\r\n    }\r\n    res = res\r\n        .replace(/[^a-z0-9 -]/g, '') // remove invalid chars\r\n        .replace(/\\s+/g, '-') // collapse whitespace and replace by -\r\n        .replace(/-+/g, '-'); // collapse dashes\r\n    return res;\r\n}\r\n//解析字符串返回字段\r\nexport const getVariables = (str) => {\r\n    const start = str.indexOf('{{');\r\n    const end = str.indexOf('}}');\r\n    if (start === -1 || end === -1)\r\n        return []; // 如果没有{{或}}，则返回空数组\r\n    const expression = str.slice(start + 2, end).trim(); // 直接截取{{和}}之间的部分\r\n    const regex = /\\w+/g;\r\n    let variables = expression.match(regex);\r\n    variables = variables.filter((v) => !/^[A-Z]+$/.test(v)); // 使用自定义的函数来过滤\r\n    return variables;\r\n};\r\n","references":["/Users/mac/Documents/ksher/directus-extension-computed-interface/src/utils.ts"]}
