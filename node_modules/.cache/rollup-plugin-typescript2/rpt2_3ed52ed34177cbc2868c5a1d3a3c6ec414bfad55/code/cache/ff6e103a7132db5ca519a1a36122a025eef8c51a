{"code":"import { watch, ref, computed } from 'vue';\r\nimport { useApi, useStores } from '@directus/extensions-sdk';\r\nexport function checkFieldInTemplate(template, field) {\r\n    const matches = template.match(/{{.*?}}/g);\r\n    return (matches || []).some((m) => m.includes(field));\r\n}\r\n/** Simple check which fields are used */\r\nfunction shouldUpdate(template, computedField, val, oldVal, pk) {\r\n    // creating new item\r\n    if (val.id && pk === '+') {\r\n        return false;\r\n    }\r\n    for (const key of Object.keys({ ...oldVal, ...val })) {\r\n        if (key !== computedField &&\r\n            checkFieldInTemplate(template, key) &&\r\n            val[key] !== oldVal[key] &&\r\n            JSON.stringify(val[key]) !== JSON.stringify(oldVal[key])) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexport const useCollectionRelations = (collection) => {\r\n    const { useRelationsStore } = useStores();\r\n    const { getRelationsForCollection } = useRelationsStore();\r\n    return ref(getRelationsForCollection(collection));\r\n};\r\nexport const useDeepValues = (values, relations, collection, computedField, pk, template) => {\r\n    const api = useApi();\r\n    const { currentUser } = useStores().useUserStore();\r\n    const finalValues = ref({});\r\n    let fieldCache = {};\r\n    let itemCache = {};\r\n    // Directus store o2m value as reference so when o2m updated, val & oldVal in watch are the same.\r\n    // This will serialize values so when o2m fields are updated, their changes can be seen.\r\n    const cloneValues = computed(() => JSON.stringify(values.value, (k, v) => v === undefined ? null : v));\r\n    watch(cloneValues, async (val, oldVal) => {\r\n        var _a, _b, _c;\r\n        const valObj = JSON.parse(val);\r\n        const oldValObj = oldVal !== undefined ? JSON.parse(oldVal) : {};\r\n        if (!shouldUpdate(template, computedField, valObj, oldValObj, pk)) {\r\n            return;\r\n        }\r\n        for (const key of Object.keys(oldValObj)) {\r\n            if (!(key in valObj)) {\r\n                valObj[key] = null;\r\n            }\r\n        }\r\n        let relationalData = {};\r\n        const pkFinal = valObj.id || pk;\r\n        for (const key of Object.keys(valObj)) {\r\n            const relation = relations.value.find((rel) => { var _a, _b; return [(_a = rel.meta) === null || _a === void 0 ? void 0 : _a.one_field, (_b = rel.meta) === null || _b === void 0 ? void 0 : _b.many_field].includes(key); });\r\n            if (!relation || !checkFieldInTemplate(template, key)) {\r\n                continue;\r\n            }\r\n            const isM2O = relation.collection === collection;\r\n            const fieldName = isM2O ? (_a = relation.meta) === null || _a === void 0 ? void 0 : _a.many_field : (_b = relation.meta) === null || _b === void 0 ? void 0 : _b.one_field;\r\n            let fieldChanges = (_c = valObj[fieldName]) !== null && _c !== void 0 ? _c : {\r\n                create: [],\r\n                update: [],\r\n                delete: [],\r\n            };\r\n            let arrayOfIds = [];\r\n            let arrayOfData = [];\r\n            if (isM2O) {\r\n                if (typeof fieldChanges === 'number' || typeof fieldChanges === 'string') {\r\n                    fieldChanges = { update: [{ id: fieldChanges }] };\r\n                    if (typeof oldValObj[key] === 'object') {\r\n                        // When saving, fieldChanges will return to the initial value.\r\n                        // We must clear cache to obtain the new value after saving.\r\n                        fieldCache = {};\r\n                        itemCache = {};\r\n                    }\r\n                }\r\n                else if (typeof fieldChanges === 'object') {\r\n                    if ('id' in fieldChanges) {\r\n                        fieldChanges = { update: [fieldChanges] };\r\n                    }\r\n                    else {\r\n                        fieldChanges = { create: [{ ...fieldChanges }] };\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (fieldChanges instanceof Array && !(oldValObj[key] instanceof Array)) {\r\n                    // When saving, fieldChanges will return to the initial value.\r\n                    // We must clear cache to obtain the new value after saving.\r\n                    fieldCache = {};\r\n                    itemCache = {};\r\n                }\r\n                if (pkFinal !== '+') {\r\n                    let data;\r\n                    if (key in fieldCache) {\r\n                        data = fieldCache[key];\r\n                    }\r\n                    else {\r\n                        data = (await api.get(`items/${collection}/${pkFinal}`, {\r\n                            params: {\r\n                                fields: [key],\r\n                            },\r\n                        })).data.data[key];\r\n                        fieldCache[key] = data;\r\n                    }\r\n                    arrayOfIds = arrayOfIds.concat(data);\r\n                }\r\n                if (fieldChanges.update) {\r\n                    const updatedIds = fieldChanges.update.map(({ id }) => id);\r\n                    arrayOfIds = arrayOfIds.filter((id) => !updatedIds.includes(id));\r\n                }\r\n                if (fieldChanges.delete) {\r\n                    arrayOfIds = arrayOfIds.filter((id) => !fieldChanges.delete.includes(id));\r\n                }\r\n            }\r\n            if (fieldChanges.update) {\r\n                arrayOfIds = arrayOfIds.concat(fieldChanges.update.map(({ id }) => id));\r\n            }\r\n            if (arrayOfIds.length) {\r\n                const relatedCollection = isM2O ? relation.related_collection : relation.collection;\r\n                const path = relatedCollection === 'directus_users' ? '/users' : `items/${relatedCollection}`;\r\n                if (relatedCollection) {\r\n                    let data;\r\n                    if (relatedCollection in itemCache && arrayOfIds.every(id => id in itemCache[relatedCollection])) {\r\n                        data = arrayOfIds.map(id => itemCache[relatedCollection][id]);\r\n                    }\r\n                    else {\r\n                        data = (await api.get(path, {\r\n                            params: { filter: { id: { _in: arrayOfIds } } },\r\n                        })).data.data;\r\n                    }\r\n                    // merging item updates\r\n                    arrayOfData = data.map((item) => {\r\n                        var _a;\r\n                        if (relatedCollection in itemCache) {\r\n                            itemCache[relatedCollection][item.id] = item;\r\n                        }\r\n                        else {\r\n                            itemCache[relatedCollection] = { [item.id]: item };\r\n                        }\r\n                        return {\r\n                            ...item,\r\n                            ...(_a = fieldChanges.update) === null || _a === void 0 ? void 0 : _a.find(({ id }) => item.id === id),\r\n                        };\r\n                    });\r\n                }\r\n            }\r\n            // must concat after request, created items doesn't have ids\r\n            if (fieldChanges.create) {\r\n                arrayOfData = arrayOfData.concat(fieldChanges.create);\r\n            }\r\n            relationalData[key] = isM2O ? arrayOfData[0] : arrayOfData;\r\n        }\r\n        finalValues.value = { ...valObj, ...relationalData, __currentUser: currentUser };\r\n    }, {\r\n        deep: false,\r\n        immediate: true,\r\n    });\r\n    return finalValues;\r\n};\r\nexport const findValueByPath = (obj, path) => {\r\n    let value = obj;\r\n    for (const i of path.split('.')) {\r\n        if (i in value) {\r\n            value = value[i];\r\n        }\r\n        else {\r\n            return { value: null, found: false };\r\n        }\r\n    }\r\n    return { value, found: true };\r\n};\r\n","references":["/Users/mac/Documents/ksher/directus-extension-computed-interface/node_modules/vue/dist/vue.d.ts","/Users/mac/Documents/ksher/directus-extension-computed-interface/node_modules/vue/dist/vue.d.ts","/Users/mac/Documents/ksher/directus-extension-computed-interface/node_modules/@directus/extensions-sdk/dist/esm/index.d.ts","/Users/mac/Documents/ksher/directus-extension-computed-interface/node_modules/@directus/shared/types.d.ts"]}
